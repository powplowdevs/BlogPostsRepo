# -*- coding: utf-8 -*-
"""liner reg

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gg9t2qD7EoNOGoX9oZvdQtB3FYIzgpU2
"""

import random
import numpy as np
import matplotlib.pyplot as plt
from statistics import mean
from matplotlib import style

style.use("fivethirtyeight")

#MAKE DATA
def create_dataset(hm, variance, step=2, cor=False):
    val = 1
    ys = []
    for i in range(hm):
        ys.append(val + random.randrange(-variance, variance))
        if cor and cor == "pos":
            val += step
        elif cor and cor == "neg":
            val -= step
    xs = [i for i in range(len(ys))]
    
    return np.array(xs, dtype=np.float64), np.array(ys, dtype=np.float64)

#FIND BEST FIT SLOPE (m)
def best_fit_slope(xs,ys):
    m = (((mean(xs) * mean(ys)) - mean(xs * ys)) / 
        ((mean(xs)**2 ) - mean(xs**2)))
     
    return m

#FIND BEST FIT Y INT (b)
def best_fit_b_int(xs, ys, m):
    b = mean(ys) - (m * mean(xs)) 
    
    return b

#FIND 2^E
def squared_error(ys_orig, ys_line):
    return sum((ys_line - ys_orig)**2)

#FIND COEIFFETAIN R^2
def cods(ys_orig, ys_line):
    y_mean_line = [mean(ys_orig) for y in ys_orig]
    squared_error_reg = squared_error(ys_orig, ys_line)
    squared_error_y_mean = squared_error(ys_orig, y_mean_line)
    return 1 - (squared_error_reg / squared_error_y_mean)

#DATA
xs, ys = create_dataset(40, 20, 2, cor="pos")

m = best_fit_slope(xs,ys)
b = best_fit_b_int(xs, ys, m)

reg_lin = [(m*x)+b for x in xs]

cod = cods(ys, reg_lin)

print(f"line is {round((round(cod, 2) * 100),2) }% accurate")

plt.scatter(xs,ys)
plt.plot(xs, reg_lin)
plt.show()